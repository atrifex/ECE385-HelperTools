'''
LICENSE:

    Copyright (c) 2016 Jeremy DeJournett

    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files
    (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, 
    merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished 
    to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
    LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    
On to the good stuff.
    
Written by Jeremy DeJournett for our ECE385 final project in Fall 2016.
This script assumes the directory structure given by https://github.com/Atrifex/ECE385-HelperTools
This script will change the text files generated by png_to_3_txt.py to valid SystemVerilog code for a sprite table.

Usage (continued)
In lab 8, things like DistX and ObjectOn are calculated in the color mapper, which is okay when you only have one object,
but is a huge mess when you have many many objects. A better strategy is to give DrawX and DrawY to every object,
and let them determine whether or not they are meant to be on at that time. Additionally, you can calculate the SpriteX
and SpriteY indexes inside the object's module itself, and just wire those as inputs to the color mapper. This way,
the color mapper does not need to know where every object is, and instead cand just map the colors according to what it's told to do.

If you have any more questions, be sure to ask one of the 385 TAs.

I also apologize in advance for how messy this is. Feel free to submit a PR if you want to try cleaning it up a bit.

'''
import math # needed ceiling and log functions.
from PIL import Image # can be obtained with a simple `pip install pillow`

github = "https://github.com/Atrifex/ECE385-HelperTools"
image_extension = ".png"
parent_dir = "./" # Atrifex, this is .. since you moved the scripts into ./scripts
bytes_dir = parent_dir + "sprite_bytes/"
sv_dir = bytes_dir
orig_dir = parent_dir + "sprite_originals/"
outfile = ''

compression_level = 16
xwidth = 0
ywidth = 0
header = ''
footer = ''

def usage():
    msg = ""
    lines = []
    lines.append("/*")
    lines.append("    This sprite table was generated using 'conv_to_sv.py'. Find out more here: " + github)
    lines.append("    To use, instantiate this module in your color mapper. The SpriteX input should be connected to")
    lines.append("        'ObjectXSize - DistX', where ObjectXSize is the width of your object in pixels along the")
    lines.append("        x direction. DistX is the horizontal distance between the DrawX pxiel and the top left corner")
    lines.append("        of the object in question, so something like: 'DistX = DrawX - ObjectXPosition' is fine.")
    lines.append("        Similarly this goes for SpriteY. Warning: If you don't do this, your image will be flipped along")
    lines.append("        the axis you ignored. This is a handy way to flip an image if you need to, though.")
    lines.append(" ")
    lines.append("    In the color mapper, you can then simply do something like:")
    lines.append("    module ColorMapper(...)")
    lines.append("    ...")
    lines.append("    logic [7:0] ObjectR, ObjectG, ObjectB")
    lines.append("    parameter ObjectXSize = 10'd10;")
    lines.append("    ...")
    lines.append("    always_comb")
    lines.append("    ...")
    lines.append("         if(ObjectOn == 1'b1)")
    lines.append("         begin")
    lines.append("             Red = ObjectR")
    lines.append("             Green = ObjectG")
    lines.append("             Blue = ObjectB")
    lines.append("         end")
    lines.append("     ...")
    lines.append("     ObjectSpriteTable ost(")
    lines.append("                           .SpriteX(ObjectXSize - DistX), .SpriteY(ObjectYSize - DistY),")
    lines.append("                           .SpriteR(ObjectR), .SpriteG(ObjectG), .SpriteB(ObjectB)")
    lines.append("                           );")
    lines.append(" ")
    lines.append("     See the comment at the top of the generation script if you're still confused.")
    lines.append("*/")
    for line in lines:
        msg += line + "\n"
    return msg

def pad_phrase(phrase, char, len):
    return len * char + phrase
    
def print_pad(phrase, char, len):
    print(pad_phrase(phrase, char, len))

def show_section_msg(phrase):
    indentation = 5
    if(phrase[-1] != '\n'):
        phrase += '\n'
    dash_width = len(phrase)
    print("\n" + indentation* " " + dash_width * "-" + "\n" + indentation*" " + phrase + indentation * " " + dash_width*"-" + "\n")
    

def combine_channels_core(channels, dist):
    # Thanks to niemmi on SO for making a more efficient and
    # correct version of this! Link: http://stackoverflow.com/a/41082911/2289030
    
    # What happens here is we find just group a bunch of colors together
    # by their distance from each other. This way, we can build a
    # dictionary that is used to replace similar colors with a color
    # from a much smaller palette. This will cause some loss of detail,
    # but if you set the dist low enough (I think 16 is perfect), 
    # you will not be able to tell the difference.
    
    result = {}
    replacements = {}
    groups = []
    group = []
    key = None
    
    print("Before combining channels, " + str(len(channels)) + " different colors are needed.")

    # Iterate through channels in ascending numerical order
    for channel, count in sorted((int(k), v) for k, v in channels.items()):
        # Add new group in case that channel doesn't fit to current group
        if group and channel - key > dist:
            groups.append((key, group))
            group = []
            key = None

        # Add channel to group
        group.append((channel, count))

        # Pick a new key in case there's none or current channel is within
        # dist from first channel in the group
        if key is None or channel - group[0][0] <= dist:
            key = channel

    # Add last group in case it exists
    if group:
        groups.append((key, group))

    for key, group in groups:
        result[key] = sum(x[1] for x in group)
        replacements[key] = [x[0] for x in group if x[0] != key]

    print("After combining channels, " + str(len(replacements)) + " different colors are needed.")
    
    return result, replacements

def combine_channels(lst, max_dist):
    counts = dict()
    replacements = dict()

    for el in lst:
        counts[el] = counts.get(el, 0) + 1
    _, replacements = combine_channels_core(counts, max_dist) 

    for i, el in enumerate(lst):
        for key, val in replacements.items():
            if(el in val):
                lst[i] = key
    return lst

def split_to_palette(lst, color):
    '''
    
    lst is assumed to be a list of integers corresponding to R, G, or B values.
    
    Create SV module with this structure:
    
    logic [NB - 1:0] palette_index;
    parameter bit [7:0] SpritePaletteR [NB - 1:0] = '{8'h$colors[0], ... , 8'hcolors[NB - 1]};
    parameter bit [NB - 1:0] SpriteTableR [W-1:0,H-1:0] = '{idx(color[0,0]), ...}
    
    '''
    
    global xwidth, ywidth, spritename, footer, outfile
    
    counts = dict() # key is the actual color, value is the count of them
    palette = dict() # key is the hex string, value is the lookup index
    
    footer += "assign Sprite" + color + " = SpritePalette" + color + "[SpriteTable" + color + "[SpriteY][SpriteX]];\n"
    
    for el in lst:
        # el = int(el.strip('\n'), 16)
        # el.strip('\n')
        counts[el] = counts.get(el, 0) + 1
    print("\nColors, with occurences, for the " + color + " channel:\n", counts, "\n")
    
    i = 0
    colors = []
    
    # Replace elements of list with their corresponding lookup values
    for key in counts:
        for idx, item in enumerate(lst):
            if item == key:
                lst[idx] = i # str(i)
        # Fill the palette dictionary (unused)
        palette[key] = i
        # Fill the list of colors
        colors.append("8'd" + str(key))
        i += 1
    num_colors = len(counts)
    
    # Calculate the number of bits needed to represent the number of colors in our palette
    num_bits = math.ceil(math.log2(num_colors))
    num_digits = math.ceil(math.log10(2**num_bits - 1))
    # print("NB, ND:", num_bits, num_digits)
    
    sprite_palette_lines = "parameter bit [7:0] SpritePalette" + color + "[" + str(num_colors - 1) + ":0] = '{"
    
    for swatch in colors:
        sprite_palette_lines += swatch + ", "
    sprite_palette_lines = sprite_palette_lines[:-2] # Strip the last ", "
    sprite_palette_lines += "};\n\n" # End the declaration
    
    # print(sprite_palette_lines)
    
    sprite_table_lines = "parameter bit [" + str(num_bits - 1) + ":0] SpriteTable" + color + "[" + str(ywidth - 1) + ":0][" + str(xwidth - 1) + ":0] = '{"

    # Generate SV code for the sprite table, now with lookup values instead of
    # actual colors.
    clen = len(lst) - 1
    i = 0
    for el in lst:
        entry = str(num_bits) + "'d" + str(el).zfill(num_digits)
        if(i % xwidth == 0):
            sprite_table_lines += "'{"
        if(i == clen):
            sprite_table_lines += entry + "}};\n\n"
        else:
            if(i % xwidth == xwidth - 1):
                sprite_table_lines += entry + "},\n"
            else:
                sprite_table_lines += entry + ","
        i += 1
    # print(sprite_table_lines)
    
    # Write the SV code to the output file
    with open(outfile, 'a+') as f:
       f.write(sprite_palette_lines)
       f.write(sprite_table_lines)

def clean_raw_list(lst):
    for i, el in enumerate(lst):
        lst[i] = int(el.strip('\n'), 16)
    return lst
    
def generate_palette(color, max_dist):
    global spritename, bytes_dir
    print("Generating palette SystemVerilog for the " + color + " channel:\n")
    fname = bytes_dir + spritename + color + ".txt"
    with open(fname) as f:
        rawlst = f.readlines()
    lst = clean_raw_list(rawlst)
    palette = combine_channels(lst, max_dist)
    split_to_palette(palette, color)

def create_sprite_table_channel(color):
    # Use this function to generate a straightforward sprite table of 8 bits wide
    # for each entry. Not recommended anymore, as generate_palette() uses less 
    # hardware resources.
    
    global xwidth, ywidth, spritename, footer, outfile, bytes_dir
    # pretty dirty, but what else are you supposed to use Python for?
    fname = bytes_dir + spritename + color + ".txt"
    with open(fname) as f:
        content = f.readlines()
    footer += "assign Sprite" + color + " = SpriteTable" + color + "[SpriteY][SpriteX];\n"

    sprite_table_lines = "parameter bit [7:0] SpriteTable" + color + "[" + str(ywidth - 1) + ":0][" + str(xwidth - 1) + ":0] = '{"
    # note that in order to index into it normally, you need to put y first? I think. This has worked for us so far.

    i = 0
    # I wanted to increment over the content, so we need an extra variable for keeping track of location.
    clength = len(content) - 1
    for hexval in content:
        hv = "8'h" + str(hexval).strip('\n').zfill(2)
        # left-pad with 0's for consistent width
        if(i % xwidth == 0):
            # start a new row of the array with '{
            sprite_table_lines += "'{"
        if(i == clength):
            # special case for the last element
            sprite_table_lines += hv + "}};\n\n"
        else:
            if(i % xwidth == xwidth - 1):
                # at the end of a row, close it off and print newline
                sprite_table_lines += hv + "},\n"
            else:
                # in the middle of the row, print the hexval and a comma
                sprite_table_lines += hv + ","
        i += 1
    # print(sprite_table_lines)
    with open(outfile, 'a+') as f:
        f.write(sprite_table_lines)

def create_sv():
    # Generate valid systemverilog code.
    global outfile, header, footer, spritename, compression_level
    with open(outfile, 'w+') as f:
        # This script overwrites the file that currently exists.
        f.write(header)
    show_section_msg("Generating SystemVerilog Code...")
    for color in ["R", "G", "B"]:
        generate_palette(color, compression_level)
        # create_sprite_table_channel
    footer += "\nendmodule\n"
    with open(outfile, 'a+') as f:
        f.write(footer)
    show_section_msg("SystemVerilog code generation complete! It's located at: " + outfile)

def test():
    global spritename, bytes_dir
    fname = bytes_dir + spritename + "R" + ".txt"
    with open(fname) as f:
        content = f.readlines()
        #split_to_palette("R", 0)
    lines = []
    for line in content:
        lines.append(int(line.strip('\n'), 16))
    combine_channels(lines, 15)

def create_image():
    # Used to compare the original image to the image
    # after palette generation
    global xwidth, ywidth, spritename, bytes_dir, orig_dir, image_extension, compression_level
    
    ans = input("\nWould you like to see a comparison of the image before and after compressing it with a palette? (y/N) ").lower()
    if(ans != 'y'):
        return
    show_section_msg("Displaying original and paletted images...")
    
    im1 = Image.open(orig_dir + spritename + image_extension)
    im1.show()
    channels = []
    for color in ["R", "G", "B"]:
        print("Processing " + color + " channel...")
        fname = bytes_dir + spritename + color + ".txt"
        with open(fname) as f:
            content = f.readlines()
            #split_to_palette("R", 0)
        lines = clean_raw_list(content)
        channels.append(combine_channels(lines, compression_level))
    #print(channels)
    imdata = list(zip(*channels))
    #print(imdata)
    im2 = Image.new("RGB", (xwidth, ywidth))
    im2.putdata(imdata)
    im2.show()

def startup():

    global github, orig_dir, sv_dir, image_extension, spritename, outfile, header, footer, xwidth, ywidth, compression_level

    print_pad("="*80, " ", 5)
    print_pad("'conv_to_sv.py', written by Jeremy DeJournett in Fall of 2016 to help make using sprite tables less terrible.", " ", 5)
    print_pad("", " ", 5)
    print_pad("This script assumes you have the directory structure given by: " + github, " ", 5)
    print_pad("", " ", 5)
    print_pad("Script Usage: ", " ", 5)
    print_pad(" 1) Place the image you want to create a sprite table from in: " + orig_dir, " ", 5)
    print_pad(" 2) Run 'png_to_3_txt.py' to get three text files, one for each color channel.", " ", 5)
    print_pad(" 3) Run this script. Supply it with the same name you gave to 'png_to_3_txt.py.", " ", 5)
    print_pad(" 4) It will generate a .sv file with your sprite table in: " + sv_dir, " ", 5)
    print_pad(" 5) You can modify this and the directories at the top of this script if you need to.", " ", 5)
    print_pad("      Extension is currently assumed to be: " + image_extension, " ", 5)
    print_pad(" 6) Instructions for usage and example code will be included as a comment at the top of the output file.", " ", 5)
    print_pad("="*80, " ", 5)

    print("Hint: If you just ran 'png_to_3_txt.py', enter the same sprite name here.")
    spritename = str(input("What's the image name? Don't include the extension: "))
    outfile = sv_dir + spritename + ".sv"
    try:
        im = Image.open(orig_dir + spritename + image_extension)
        xwidth, ywidth = im.size
    except FileNotFoundError:
        print("Could not automatically find the image you're talking about. If you have the output text files, enter the image dimensions manually.")
        xwidth = int(input("What's the sprite's x width in pixels? ")) # These two could be read from Image().size(), for now just set them manually.
        ywidth = int(input("What's the sprite's y width in pixels? "))

    try:
        cl = input("What compression level do you want? Typically the number of resulting colors in a palette is 256/compression_level. (" + str(compression_level) + "): ")
        if(cl != ""):
            cl = int(cl)
            if(cl > 0 and cl < 256):
                compression_level = cl
            else:
                print("Entered compression level is out of range of valid values (1-255). Using default.")
    except ValueError:
        print("What you entered was not a valid compression level. Using default.")
    ans = input("Do you want the usage details to included at the top of the output file? (Y/n) ").lower()
    print(ans)
    if(ans == 'n'):
        header = ''
    else:
        header = usage()
    header += "module " + spritename + "(input [9:0] SpriteX, SpriteY,\n"
    header += ' ' * 12 + "output [7:0] SpriteR, SpriteG, SpriteB);\n\n"

    create_image()
    create_sv()
startup()
